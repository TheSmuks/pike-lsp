---
phase: 14-typescript-side-caching
plan: 02
type: execute
wave: 2
depends_on: [14-01]
files_modified:
  - packages/pike-lsp-server/src/services/request-deduper.ts
  - packages/pike-lsp-server/src/services/index.ts
  - packages/pike-lsp-server/src/features/diagnostics.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "RequestDeduper prevents duplicate analyze() calls for same uri:version"
    - "Promise cleanup happens on resolve/reject via finally()"
    - "Deduper is integrated into validateDocument flow"
  artifacts:
    - path: "packages/pike-lsp-server/src/services/request-deduper.ts"
      provides: "RequestDeduper class with dedupe() method"
      exports: ["RequestDeduper"]
      min_lines: 40
    - path: "packages/pike-lsp-server/src/services/index.ts"
      contains: "RequestDeduper"
    - path: "packages/pike-lsp-server/src/features/diagnostics.ts"
      contains: "analyzeDeduper"
  key_links:
    - from: "diagnostics.ts:validateDocument"
      to: "request-deduper.ts:RequestDeduper.dedupe"
      via: "dedupe() call wrapping bridge.analyze()"
      pattern: "analyzeDeduper\\.dedupe\\("
---

<objective>
Implement RequestDeduper class IF logging from 14-01 confirms duplicate analyze() calls occur.

Purpose: Prevent thundering herd of concurrent Pike calls during document change events by deduplicating analyze() calls at the TypeScript LSP server level. This complements PikeBridge's existing inflight deduping by operating at the LSP feature handler layer.

Output: RequestDeduper class that wraps BridgeManager.analyze() calls and prevents duplicate in-flight requests for the same document version.
</objective>

<execution_context>
@~/.claude/get-shit-done/templates/CLAUDE.md
@.planning/PROJECT.md
@.planning/ROADMAP.md

@.planning/phases/14-typescript-side-caching/14-CONTEXT.md
@.planning/phases/14-typescript-side-caching/14-RESEARCH.md
@.planning/phases/14-typescript-side-caching/14-01-SUMMARY.md

@packages/pike-lsp-server/src/services/bridge-manager.ts
@packages/pike-lsp-server/src/features/diagnostics.ts
@packages/pike-bridge/src/bridge.ts
</context>

<context>
**IMPORTANT**: This plan should ONLY proceed if 14-01 logging confirms that duplicate analyze() calls actually occur.

If 14-01 shows NO duplicates:
1. This plan should be skipped
2. Phase 14 should conclude that existing PikeBridge deduping is sufficient
3. Update ROADMAP to document this finding

If 14-01 shows duplicates DO occur:
1. Implement this plan as written
2. The RequestDeduper will prevent duplicate analyze() calls for same uri:version
</context>

<tasks>

<task type="checkpoint:decision" gate="blocking">
  <decision>Should RequestDeduper be implemented based on 14-01 logging results?</decision>
  <context>
    Plan 14-01 added logging to track whether duplicate analyze() calls occur. The logging should reveal:
    - Do multiple validateDocument() calls happen concurrently for the same document?
    - Does the existing PikeBridge inflight deduping prevent duplicate IPC calls?
    - Is there a gap between LSP feature handler level and IPC level that needs deduping?

    If duplicates were observed: Implement RequestDeduper (proceed with remaining tasks)
    If no duplicates: Skip this plan and document that existing deduping is sufficient
  </context>
  <options>
    <option id="implement-deduper">
      <name>Implement RequestDeduper</name>
      <pros>Prevents any duplicate analyze() calls at LSP layer; provides defense-in-depth</pros>
      <cons>Adds complexity if problem doesn't actually exist; additional code to maintain</cons>
    </option>
    <option id="skip-deduper">
      <name>Skip - Existing deduping is sufficient</name>
      <pros>No unnecessary complexity; PikeBridge already handles inflight deduping</pros>
      <cons>If problem emerges later, will need to revisit</cons>
    </option>
  </options>
  <resume-signal>Select: implement-deduper or skip-deduper</resume-signal>
</task>

<task type="auto">
  <name>Create RequestDeduper class</name>
  <files>packages/pike-lsp-server/src/services/request-deduper.ts</files>
  <action>
    Create a new RequestDeduper class with the following implementation:

    ```typescript
    import type { Logger } from '@pike-lsp/core';

    /**
     * Request deduplication for in-flight requests.
     *
     * Prevents duplicate in-flight requests for the same key by tracking
     * pending promises and returning the existing promise to concurrent callers.
     *
     * @template T - The type of value the promise resolves to
     */
    export class RequestDeduper<T> {
        private pending = new Map<string, Promise<T>>();

        constructor(private readonly name: string, private readonly logger?: Logger) {}

        /**
         * Execute a function with deduping by key.
         *
         * If a request with the same key is in-flight, reuse its promise.
         * Otherwise, execute the function and track the promise until completion.
         *
         * @param key - Deduplication key (e.g., `${uri}:${version}`)
         * @param fn - Async function to execute if no inflight request
         * @returns Promise that resolves with the function result
         */
        async dedupe(key: string, fn: () => Promise<T>): Promise<T> {
            const existing = this.pending.get(key);
            if (existing) {
                this.logger?.debug(`[DEDUPE] Reusing inflight request`, {
                    deduper: this.name,
                    key,
                });
                return existing;
            }

            this.logger?.debug(`[DEDUPE] Starting new request`, {
                deduper: this.name,
                key,
            });

            const promise = fn().finally(() => {
                this.pending.delete(key);
                this.logger?.debug(`[DEDUPE] Request cleared`, {
                    deduper: this.name,
                    key,
                });
            });

            this.pending.set(key, promise);
            return promise;
        }

        /**
         * Clear all pending requests for a specific key or all keys.
         *
         * @param key - Optional key to clear. If omitted, clears all.
         */
        clear(key?: string): void {
            if (key) {
                this.pending.delete(key);
            } else {
                this.pending.clear();
            }
        }

        /**
         * Get the number of pending requests.
         */
        get size(): number {
            return this.pending.size;
        }
    }
    ```

    DO NOT:
    - Add TTL or timeout handling (PikeBridge already handles request timeouts)
    - Add retry logic (errors should propagate to all waiters)
    - Make this a full caching layer (this is deduping only, not result caching)
  </action>
  <verify>grep -c "class RequestDeduper" packages/pike-lsp-server/src/services/request-deduper.ts equals 1</verify>
  <done>RequestDeduper class exists with dedupe() method and proper promise cleanup</done>
</task>

<task type="auto">
  <name>Export RequestDeduper from services/index.ts</name>
  <files>packages/pike-lsp-server/src/services/index.ts</files>
  <action>
    Add RequestDeduper to the services barrel export:

    1. Import: `export { RequestDeduper } from './request-deduper.js';`
    2. Update Services type if needed to include analyzeDeduper instance

    Follow the existing barrel export pattern used for other services.
  </action>
  <verify>grep "RequestDeduper" packages/pike-lsp-server/src/services/index.ts shows export statement</verify>
  <done>RequestDeduper is exported from services module</done>
</task>

<task type="auto">
  <name>Integrate RequestDeduper into diagnostics.ts</name>
  <files>packages/pike-lsp-server/src/features/diagnostics.ts</files>
  <action>
    Integrate RequestDeduper into the validateDocument flow:

    1. After services are initialized, create deduper instance:
       ```typescript
       const analyzeDeduper = new RequestDeduper<AnalyzeResponse>(
           'analyze',
           log  // pass logger for debugging
       );
       ```

    2. In validateDocument(), wrap the bridge.analyze() call:
       ```typescript
       const analyzeResult = await analyzeDeduper.dedupe(
           `${uri}:${version}`,
           () => bridge.analyze(text, ['parse', 'introspect', 'diagnostics'], filename, version)
       );
       ```

    3. In document close handler, clear pending requests:
       ```typescript
       analyzeDeduper.clear(uri);
       ```

    4. On server shutdown, clear all pending:
       ```typescript
       analyzeDeduper.clear();
       ```

    DO NOT modify the existing debounce logic - RequestDeduper complements it.
  </action>
  <verify>grep -n "analyzeDeduper" packages/pike-lsp-server/src/features/diagnostics.ts shows instance creation and dedupe() call</verify>
  <done>validateDocument uses RequestDeduper to prevent duplicate analyze() calls</done>
</task>

</tasks>

<verification>
After implementation:
1. Run E2E test to verify LSP functionality still works: `cd packages/vscode-pike && pnpm test:features`
2. Check logs to confirm [DEDUPE] messages appear when rapid edits occur
3. Verify that concurrent analyze requests are properly deduped

If "skip-deduper" was selected:
- Update ROADMAP.md to document that Phase 14 concluded existing PikeBridge deduping is sufficient
- No code changes needed
</verification>

<success_criteria>
If implement-deduper selected:
1. RequestDeduper class exists with dedupe() method
2. validateDocument() uses deduper to wrap analyze() calls
3. Promise cleanup happens on resolve/reject via finally()
4. E2E tests pass

If skip-deduper selected:
1. ROADMAP updated with finding that existing deduping is sufficient
2. Phase 14 marked as complete with documented rationale
</success_criteria>

<output>
After completion, create `.planning/phases/14-typescript-side-caching/14-02-SUMMARY.md`

The summary should include:
- Decision made (implement or skip)
- If implemented: Code changes made and performance impact
- If skipped: Rationale and evidence that existing deduping is sufficient
- Phase 14 completion status
</output>
