---
phase: 02-safety-net
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [package.json, .husky/pre-push, .gitignore]
autonomous: true

must_haves:
  truths:
    - "Husky v9 is installed as devDependency in root package.json"
    - ".husky/pre-push hook file exists and is executable (+x permission)"
    - "Running 'git push' triggers the pre-push hook automatically"
    - "Pre-push hook validates: TypeScript builds, Pike compiles, smoke tests pass"
    - "Failed validation blocks push with exit code 1"
  artifacts:
    - path: "node_modules/husky"
      provides: "Husky v9 git hooks management"
      contains: ".husky/sh/pre-push or husky executable"
    - path: ".husky/pre-push"
      provides: "Pre-push validation script"
      min_lines: 15
    - path: ".gitignore"
      provides: "Git ignore entries for Husky"
      contains: ".husky/_ or husky.sh references"
  key_links:
    - from: ".git/hooks/pre-push"
      to: ".husky/pre-push"
      via: "symlink created by Husky init"
      pattern: ".husky/pre-push"
    - from: "pnpm install"
      to: ".husky/pre-push"
      via: "husky install in prepare script"
      pattern: "prepare.*husky"
---

<objective>
Set up pre-push git hook using Husky v9 to catch regressions before they reach the remote repository.

Purpose: Enable "green main, not green commits" philosophy - allow broken intermediate commits on feature branches while enforcing validation on push. Maintain defense in depth without strangling minute-by-minute workflow.

Output: Working pre-push hook that validates TypeScript builds, Pike compilation, and smoke tests before allowing push.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-safety-net/02-CONTEXT.md
@.planning/phases/02-safety-net/02-RESEARCH.md
@.planning/phases/01-lean-observability/01-03-SUMMARY.md
@package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install and initialize Husky v9</name>
  <files>package.json, .husky/pre-push, .gitignore</files>
  <action>
    1. Install Husky v9 as devDependency:
       ```bash
       pnpm add -D -w husky
       ```

    2. Initialize Husky (creates .husky/ directory and git config):
       ```bash
       pnpm exec husky init
       ```

    3. Verify .husky/ directory was created with pre-commit hook (template we'll replace)

    4. Add .husky/_ to .gitignore if not present (Husky creates shell script cache)

    IMPORTANT: Do NOT create a pre-commit hook - we only want pre-push validation. Delete any pre-commit template that husky init creates.
  </action>
  <verify>
    - [ ] package.json contains "husky" in devDependencies
    - [ ] .husky/ directory exists
    - [ ] .git/config contains "core.hooksPath=.husky"
    - [ ] pre-commit hook was deleted (if created by init)
  </verify>
  <done>
    Husky v9 installed and initialized, .husky/ directory ready, no pre-commit hook exists (pre-push only philosophy)
  </done>
</task>

<task type="auto">
  <name>Task 2: Create pre-push hook with validation commands</name>
  <files>.husky/pre-push</files>
  <action>
    Create .husky/pre-push with the following content:
    ```bash
    #!/bin/sh
    # Pre-push hook: Validates build, Pike compilation, and smoke tests
    # Philosophy: "Green main, not green commits" - allow broken local commits

    set -e  # Exit on error

    echo "[Pre-push] Running validations..."

    # 1. TypeScript builds
    echo "[Pre-push] Building all packages..."
    pnpm -r build || {
      echo "FAILED: TypeScript build failed. Push aborted."
      echo "Fix build errors or use 'git push --no-verify' to bypass (not recommended)."
      exit 1
    }

    # 2. Pike compiles
    echo "[Pre-push] Checking Pike compilation..."
    pike -e 'compile_file("pike-scripts/analyzer.pike");' || {
      echo "FAILED: Pike compilation failed. Push aborted."
      echo "Fix Pike syntax errors or use 'git push --no-verify' to bypass."
      exit 1
    }

    # 3. Smoke tests (if smoke test exists - plan 02-02 creates it)
    if [ -f "packages/pike-lsp-server/src/tests/smoke.test.ts" ]; then
      echo "[Pre-push] Running smoke tests..."
      pnpm --filter @pike-lsp/pike-lsp-server test:smoke || {
        echo "FAILED: Smoke tests failed. Push aborted."
        echo "Fix failing tests or use 'git push --no-verify' to bypass."
        exit 1
      }
    else
      echo "[Pre-push] Smoke tests not yet available (plan 02-02 pending)..."
    fi

    echo "[Pre-push] All validations passed!"
    ```

    After creating the file, ensure it's executable:
    ```bash
    chmod +x .husky/pre-push
    ```

    NOTE: Smoke test check is conditional - if plan 02-02 hasn't run yet, the hook still works but skips that validation.
  </action>
  <verify>
    - [ ] .husky/pre-push file exists
    - [ ] File is executable (ls -l shows -rwxr-xr-x)
    - [ ] Contains TypeScript build check: "pnpm -r build"
    - [ ] Contains Pike compile check: "pike -e 'compile_file...'"
    - [ ] Contains conditional smoke test check
  </verify>
  <done>
    Pre-push hook created, executable, and contains all three validation checks with helpful error messages
  </done>
</task>

<task type="auto">
  <name>Task 3: Verify pre-push hook triggers and validates correctly</name>
  <files>.husky/pre-push</files>
  <action>
    Test the pre-push hook works:

    1. Test hook executes manually:
       ```bash
       ./.husky/pre-push
       ```
       Expected: "All validations passed!" message

    2. Test git push integration (dry-run with a temporary branch):
       ```bash
       git checkout -b test-pre-push-$(date +%s)
       git push -u origin test-pre-push-$(date +%s) --dry-run
       git checkout -
       git branch -D test-pre-push-$(date +%s)
       ```
       Expected: Hook runs before push attempt

    3. Verify exit codes work by temporarily breaking each check:
       - Break build: add syntax error to a .ts file, run hook
       - Break Pike: add syntax error to analyzer.pike, run hook
       - Each should exit 1 with appropriate error message

    NOTE: We're testing the hook executes, not testing a full push (which would require a remote).
  </action>
  <verify>
    - [ ] Running ./.husky/pre-push directly completes successfully
    - [ ] Hook shows expected output: "[Pre-push] Running validations..."
    - [ ] Build failure causes exit 1 with helpful message
    - [ ] Pike compilation failure causes exit 1 with helpful message
    - [ ] --no-verify bypass works (git push --no-verify skips hook)
  </verify>
  <done>
    Pre-push hook executes on push attempt, validates all checks, blocks failed pushes with clear error messages, allows bypass with --no-verify flag
  </done>
</task>

</tasks>

<verification>
Overall phase verification:

1. Husky is properly configured in git (core.hooksPath=.husky)
2. Pre-push hook runs automatically on push
3. TypeScript build validation works
4. Pike compilation validation works
5. Smoke test validation works (after plan 02-02 completes)
6. Failed validation blocks push (exit code 1)
7. Bypass with --no-verify works
</verification>

<success_criteria>
1. .husky/pre-push hook exists and is executable
2. Running `git push` triggers the hook
3. Hook validates: TypeScript builds, Pike compiles, smoke tests pass (if available)
4. Failed validation blocks push with helpful error message
5. `git push --no-verify` bypasses the hook
</success_criteria>

<output>
After completion, create `.planning/phases/02-safety-net/02-01-SUMMARY.md`
</output>
