---
phase: 04-server-grouping
plan: 05
type: execute
wave: 3
depends_on: [04-01, 04-02, 04-03, 04-04]
files_modified:
  - packages/pike-lsp-server/src/features/hierarchy.ts
  - packages/pike-lsp-server/src/features/advanced.ts
  - packages/pike-lsp-server/src/features/index.ts
  - packages/pike-lsp-server/src/server.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "features/hierarchy.ts exports registerHierarchyHandlers function"
    - "features/advanced.ts exports registerAdvancedHandlers function"
    - "server.ts is reduced to ~150 lines (wiring only)"
    - "server.ts uses Services interface"
    - "server.ts imports and calls all registerXHandlers functions"
    - "All feature handlers are registered before documents.listen(connection)"
  artifacts:
    - path: "packages/pike-lsp-server/src/features/hierarchy.ts"
      provides: "Hierarchy feature handlers"
      exports: ["registerHierarchyHandlers"]
    - path: "packages/pike-lsp-server/src/features/advanced.ts"
      provides: "Advanced feature handlers"
      exports: ["registerAdvancedHandlers"]
    - path: "packages/pike-lsp-server/src/server.ts"
      provides: "LSP server wiring and initialization"
      min_lines: 100
      max_lines: 200
  key_links:
    - from: "server.ts"
      to: "features/index.ts"
      via: "import registerXHandlers"
      pattern: "import.*register.*Handlers.*from.*features"
    - from: "server.ts"
      to: "services/index.ts"
      via: "import Services"
      pattern: "import.*Services.*from.*services"
---

<objective>
Extract remaining handlers and refactor server.ts to wiring-only.

Purpose: Complete the modularization by extracting hierarchy, semantic tokens, code actions, formatting, and other advanced handlers, then reduce server.ts to ~150 lines.
Output: features/hierarchy.ts, features/advanced.ts, and refactored server.ts
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Codebase intelligence
@.planning/intel/summary.md

# Source code - server.ts to refactor
@packages/pike-lsp-server/src/server.ts

# Previous plan summaries
@.planning/phases/04-server-grouping/04-01-SUMMARY.md
@.planning/phases/04-server-grouping/04-02-SUMMARY.md
@.planning/phases/04-server-grouping/04-03-SUMMARY.md
@.planning/phases/04-server-grouping/04-04-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extract hierarchy handlers to features/hierarchy.ts</name>
  <files>packages/pike-lsp-server/src/features/hierarchy.ts</files>
  <action>
Create `packages/pike-lsp-server/src/features/hierarchy.ts`:

Extract call and type hierarchy handlers:
1. **callHierarchy.onPrepare** (lines 2383-2436 in server.ts)
2. **callHierarchy.onIncomingCalls** (lines 2437-2523 in server.ts)
3. **callHierarchy.onOutgoingCalls** (lines 2524-2612 in server.ts)
4. **typeHierarchy.onPrepare** (lines 2613-2666 in server.ts)
5. **typeHierarchy.onSupertypes** (lines 2667-2711 in server.ts)
6. **typeHierarchy.onSubtypes** (lines 2712-3728 in server.ts)

Pattern:
```typescript
import { Connection } from 'vscode-languageserver/node.js';
import type { Services } from '../services/index.js';

export function registerHierarchyHandlers(
  connection: Connection,
  services: Services
): void {
  const { bridge, logger, documentCache } = services;
  const log = logger.child('hierarchy');

  connection.languages.callHierarchy.onPrepare((params) => {
    // ... with try/catch
  });

  connection.languages.callHierarchy.onIncomingCalls((params) => {
    // ... with try/catch
  });

  connection.languages.callHierarchy.onOutgoingCalls((params) => {
    // ... with try/catch
  });

  connection.languages.typeHierarchy.onPrepare((params) => {
    // ... with try/catch
  });

  connection.languages.typeHierarchy.onSupertypes((params) => {
    // ... with try/catch
  });

  connection.languages.typeHierarchy.onSubtypes((params) => {
    // ... with try/catch
  });
}
```
  </action>
  <verify>grep -q "export function registerHierarchyHandlers" packages/pike-lsp-server/src/features/hierarchy.ts && grep -q "callHierarchy.onPrepare\|typeHierarchy.onPrepare" packages/pike-lsp-server/src/features/hierarchy.ts</verify>
  <done>features/hierarchy.ts exports registerHierarchyHandlers with call and type hierarchy</done>
</task>

<task type="auto">
  <name>Task 2: Extract advanced handlers to features/advanced.ts</name>
  <files>packages/pike-lsp-server/src/features/advanced.ts</files>
  <action>
Create `packages/pike-lsp-server/src/features/advanced.ts`:

Extract remaining handlers that don't fit in other categories:
1. **onFoldingRanges** (lines 3787-3874 in server.ts)
2. **languages.semanticTokens.on** (lines 3875-4007 in server.ts)
3. **languages.inlayHint.on** (lines 4008-4082 in server.ts)
4. **onSelectionRanges** (lines 4087-4153 in server.ts)
5. **onCodeAction** (lines 4159-4266 in server.ts)
6. **onDocumentFormatting** (lines 4271-4286 in server.ts)
7. **onDocumentRangeFormatting** (lines 4291-4315 in server.ts)
8. **onDocumentLinks** (lines 4442-4537 in server.ts)
9. **onCodeLens** (lines 4621-4657 in server.ts)
10. **onCodeLensResolve** (lines 4662-4693 in server.ts)

Keep helper functions:
- formatPikeCode
- resolveModulePath
- resolveIncludePath
- getDocumentDirectory

Pattern:
```typescript
import { Connection } from 'vscode-languageserver/node.js';
import type { Services } from '../services/index.js';

export function registerAdvancedHandlers(
  connection: Connection,
  services: Services
): void {
  const { bridge, logger, documentCache, globalSettings, includePaths } = services;
  const log = logger.child('advanced');

  connection.onFoldingRanges((params) => {
    // ... with try/catch
  });

  connection.languages.semanticTokens.on((params) => {
    // ... with try/catch
  });

  // ... rest of handlers
}
```

Note: globalSettings and includePaths need to be added to Services interface for these handlers to work.
  </action>
  <verify>grep -q "export function registerAdvancedHandlers" packages/pike-lsp-server/src/features/advanced.ts && grep -q "onFoldingRanges\|onCodeAction\|onDocumentFormatting" packages/pike-lsp-server/src/features/advanced.ts</verify>
  <done>features/advanced.ts exports registerAdvancedHandlers with formatting, code actions, semantic tokens, etc.</done>
</task>

<task type="auto">
  <name>Task 3: Update services/index.ts to include globalSettings and includePaths</name>
  <files>packages/pike-lsp-server/src/services/index.ts</files>
  <action>
Update `packages/pike-lsp-server/src/services/index.ts`:

Add globalSettings and includePaths to Services interface:

```typescript
import type { Logger } from '../core/logging.js';
import type { DocumentCache } from './document-cache.js';
import type { BridgeManager } from './bridge-manager.js';
import type { TypeDatabase } from '../type-database.js';
import type { WorkspaceIndex } from '../workspace-index.js';
import type { StdlibIndexManager } from '../stdlib-index.js';
import type { PikeSettings } from '../core/types.js';

export interface Services {
  bridge: BridgeManager;
  logger: Logger;
  documentCache: DocumentCache;
  typeDatabase: TypeDatabase;
  workspaceIndex: WorkspaceIndex;
  stdlibIndex: StdlibIndexManager | null;
  globalSettings: PikeSettings;
  includePaths: string[];
}

// Re-export for convenience
export { DocumentCache } from './document-cache.js';
export { BridgeManager, HealthStatus } from './bridge-manager.js';
```
  </action>
  <verify>grep -q "globalSettings:" packages/pike-lsp-server/src/services/index.ts && grep -q "includePaths:" packages/pike-lsp-server/src/services/index.ts</verify>
  <done>Services interface includes globalSettings and includePaths</done>
</task>

<task type="auto">
  <name>Task 4: Refactor server.ts to wiring-only (~150 lines)</name>
  <files>packages/pike-lsp-server/src/server.ts</files>
  <action>
Refactor `packages/pike-lsp-server/src/server.ts` to be wiring-only:

The new server.ts should:
1. Import Connection, TextDocuments, ProposedFeatures from vscode-languageserver
2. Import all feature registration functions
3. Import service classes
4. Create connection and documents
5. Initialize services (bridge, typeDatabase, workspaceIndex, stdlibIndex)
6. Create Services object
7. Register all feature handlers
8. Handle initialization (onInitialize, onInitialized)
9. Start listening

Structure:
```typescript
// Imports
import { createConnection, ProposedFeatures, ... } from 'vscode-languageserver/node.js';
import { TextDocuments, TextDocument } from 'vscode-languageserver-textdocument';
import { PikeBridge } from '@pike-lsp/pike-bridge';
import { TypeDatabase } from './type-database.js';
import { WorkspaceIndex } from './workspace-index.js';
import { StdlibIndexManager } from './stdlib-index.js';
import { BridgeManager } from './services/bridge-manager.js';
import { DocumentCache } from './services/document-cache.js';
import { Logger } from './core/logging.js';
import { PikeSettings, defaultSettings } from './core/types.js';
import * as features from './features/index.js';

// Create connection and documents
const connection = createConnection(ProposedFeatures.all);
const documents = new TextDocuments(TextDocument);

// Services
const logger = new Logger('PikeLSPServer');
const documentCache = new DocumentCache();
const typeDatabase = new TypeDatabase();
const workspaceIndex = new WorkspaceIndex();
let stdlibIndex: StdlibIndexManager | null = null;
let bridgeManager: BridgeManager | null = null;

let globalSettings: PikeSettings = defaultSettings;
let includePaths: string[] = [];

// Create Services bundle
function createServices(): features.Services {
  return {
    bridge: bridgeManager!,
    logger,
    documentCache,
    typeDatabase,
    workspaceIndex,
    stdlibIndex,
    globalSettings,
    includePaths,
  };
}

// Initialize
connection.onInitialize(async (params) => {
  // Initialize bridge, stdlibIndex, bridgeManager
  // Return capabilities
});

connection.onInitialized(async () => {
  // Start bridge, pre-warm stdlib, index workspace
});

// Register feature handlers (before documents.listen!)
connection.onDidChangeConfiguration((change) => {
  // Update globalSettings, includePaths
  // Revalidate documents
});

// Register all feature handlers
const services = createServices();
features.registerDiagnosticsHandlers(connection, services, documents);
features.registerNavigationHandlers(connection, services);
features.registerEditingHandlers(connection, services);
features.registerSymbolsHandlers(connection, services);
features.registerHierarchyHandlers(connection, services);
features.registerAdvancedHandlers(connection, services);

// Shutdown
connection.onShutdown(async () => {
  await bridgeManager?.stop();
});

connection.onExit(() => {
  bridgeManager?.stop().catch(console.error);
});

// Listen for document events (must be after all handler registration)
documents.listen(connection);

// Start listening
connection.listen();
```

Target: ~150 lines total. All handler logic should be in feature modules.
  </action>
  <verify>wc -l packages/pike-lsp-server/src/server.ts | awk '{if ($1 <= 200) print "PASS"; else print "FAIL: " $1 " lines"}'</verify>
  <done>server.ts is reduced to wiring-only initialization, ~150 lines</done>
</task>

<task type="auto">
  <name>Task 5: Update features/index.ts to export new handlers</name>
  <files>packages/pike-lsp-server/src/features/index.ts</files>
  <action>
Update `packages/pike-lsp-server/src/features/index.ts`:

```typescript
export { registerNavigationHandlers } from './navigation.js';
export { registerEditingHandlers } from './editing.js';
export { registerSymbolsHandlers } from './symbols.js';
export { registerDiagnosticsHandlers } from './diagnostics.js';
export { registerHierarchyHandlers } from './hierarchy.js';
export { registerAdvancedHandlers } from './advanced.js';

// Export Services type for convenience
export type { Services } from '../services/index.js';
```
  </action>
  <verify>grep -q "registerHierarchyHandlers\|registerAdvancedHandlers" packages/pike-lsp-server/src/features/index.ts</verify>
  <done>features/index.ts exports all feature registration functions</done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `cd packages/pike-lsp-server && npx tsc --noEmit`
2. server.ts is ~150 lines (wc -l shows <= 200 to allow some buffer)
3. All feature handlers are registered before documents.listen(connection)
4. No handler logic remains in server.ts
</verification>

<success_criteria>
1. features/hierarchy.ts exists with registerHierarchyHandlers
2. features/advanced.ts exists with registerAdvancedHandlers
3. server.ts is ~150 lines, wiring-only
4. All handlers registered via registerXHandlers functions
5. features/index.ts exports all handlers
</success_criteria>

<output>
After completion, create `.planning/phases/04-server-grouping/04-05-SUMMARY.md`
</output>
